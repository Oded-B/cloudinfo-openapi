/*
 * Product Info.
 *
 * The product info application uses the cloud provider APIs to asynchronously fetch and parse instance type attributes and prices, while storing the results in an in memory cache and making it available as structured data through a REST API.
 *
 * API version: 0.0.1
 * Contact: info@banzaicloud.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ImagesApiService ImagesApi service
type ImagesApiService service

type ApiGetImagesRequest struct {
	ctx _context.Context
	ApiService *ImagesApiService
	provider string
	service string
	region string
	gpu *string
	version *string
	os *string
	pkeVersion *string
	latestOnly *string
}

func (r ApiGetImagesRequest) Gpu(gpu string) ApiGetImagesRequest {
	r.gpu = &gpu
	return r
}
func (r ApiGetImagesRequest) Version(version string) ApiGetImagesRequest {
	r.version = &version
	return r
}
func (r ApiGetImagesRequest) Os(os string) ApiGetImagesRequest {
	r.os = &os
	return r
}
func (r ApiGetImagesRequest) PkeVersion(pkeVersion string) ApiGetImagesRequest {
	r.pkeVersion = &pkeVersion
	return r
}
func (r ApiGetImagesRequest) LatestOnly(latestOnly string) ApiGetImagesRequest {
	r.latestOnly = &latestOnly
	return r
}

func (r ApiGetImagesRequest) Execute() ([]Image, *_nethttp.Response, error) {
	return r.ApiService.GetImagesExecute(r)
}

/*
 * GetImages Provides a list of available images on a given provider in a specific region for a service.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param provider
 * @param service
 * @param region
 * @return ApiGetImagesRequest
 */
func (a *ImagesApiService) GetImages(ctx _context.Context, provider string, service string, region string) ApiGetImagesRequest {
	return ApiGetImagesRequest{
		ApiService: a,
		ctx: ctx,
		provider: provider,
		service: service,
		region: region,
	}
}

/*
 * Execute executes the request
 * @return []Image
 */
func (a *ImagesApiService) GetImagesExecute(r ApiGetImagesRequest) ([]Image, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Image
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.GetImages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/providers/{provider}/services/{service}/regions/{region}/images"
	localVarPath = strings.Replace(localVarPath, "{"+"provider"+"}", _neturl.PathEscape(parameterToString(r.provider, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", _neturl.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", _neturl.PathEscape(parameterToString(r.region, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.gpu != nil {
		localVarQueryParams.Add("gpu", parameterToString(*r.gpu, ""))
	}
	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.os != nil {
		localVarQueryParams.Add("os", parameterToString(*r.os, ""))
	}
	if r.pkeVersion != nil {
		localVarQueryParams.Add("pkeVersion", parameterToString(*r.pkeVersion, ""))
	}
	if r.latestOnly != nil {
		localVarQueryParams.Add("latestOnly", parameterToString(*r.latestOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
